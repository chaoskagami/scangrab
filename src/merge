#!/bin/bash
# Copyright (C) 2015  Jon Feldman/@chaoskagami
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

TARGET="$1"

if [ "$MINIFY" = "" ]; then
	MINIFY=1
fi

if [ "$COMPRESS" = "" ]; then
	COMPRESS="xz"
fi

if [ "$BRUTE" = "1" ]; then
	mkdir -p ./dist
	TARGET="./dist/scangrab"
fi

if [ "$TARGET" = "" ]; then
	TARGET="./scangrab.min"
elif [ "$TARGET" = "-h" ]; then
	echo "This script merges the modules and the core to make"
	echo "a standalone script. By default, the output is"
	echo ""
	echo "	./scangrab.min"
	echo ""
	echo "but you can also pass where you would like as the"
	echo "first parameter, like so:"
	echo ""
	echo "	./merge /usr/local/bin/scangrab"
	echo ""
	echo "This script DOES check to see if you passed it a"
	echo "folder, and will refuse to work."
	echo ""
	echo "It also optimizes the output for size; e.g. minify."
	echo "If you don't want minified output, open this script"
	echo "and change MINIFY=1 to MINIFY=0 at the top."
	echo ""
	echo "Scangrab will experimentally work with zsh;"
	echo "change the shebang if you feel like it."
	echo ""
	echo "We can also make a decompressible archive too."
	echo "Export COMPRESS as one of {none,gzip,bzip2,xz}"
	echo ""
	echo "xz is default. Note that a system without the"
	echo "tools won't even be able to execute it."
	echo ""
	echo "Additionally, setting BRUTE=1 will build all of"
	echo "the different versions for comparison and store"
	echo "in a subfolder named dist."
	exit 0
fi

if [ -d "$TARGET" ]; then
	echo "Was told to overwrite a folder. Cowardly refusing."
	exit 1
fi

if [ "$(readlink -f $TARGET)" = "$(pwd)/scangrab" ] || [ "$(readlink -f $TARGET)" = "$(pwd)/main" ] || [ "$(readlink -f $TARGET)" = "$(pwd)/support" ] || [ "$(readlink -f $TARGET)" = "$(pwd)/merge" ] || [ "$(readlink -f $TARGET)" = "$(pwd)/rev" ] || [ "$(readlink -f $TARGET)" = "$(pwd)/modules" ]; then
	echo "Refusing to clobber any actual files in repo. Why would you do that?"
	exit 1
fi

# Shebang.
echo "#!/bin/bash" > $TARGET.tmp

# Append support.
echo "#############################################" >> $TARGET.tmp
echo "#####@ORIGINAL-FILE 'support'" >> $TARGET.tmp
cat support >> $TARGET.tmp

# Regenerate revision file.
git show | head -n1 | sed -e 's|commit |rev=|' > rev
git branch | grep '*' | sed -e 's|* |branch=|g' >> rev
echo "#############################################" >> $TARGET.tmp
echo "#####@ORIGINAL-FILE 'rev'" >> $TARGET.tmp
cat rev >> $TARGET.tmp

# Module code.
MODS=($(find modules/ -maxdepth 1 -type f | sed 's|modules/||g'))

echo "#############################################" >> $TARGET.tmp
echo "#####@AUTOGENERATED 'MODS'" >> $TARGET.tmp
# Module list.
echo "MODS=(${MODS[@]})" >> $TARGET.tmp
echo "#############################################" >> $TARGET.tmp

# Module content
for module in ${MODS[@]}; do
	if [ -d modules/${module}.mods ]; then
		# This module has subcomponents. Paste an array of what is there.
		declare -a list
		list=($(find modules/${module}.mods/ -maxdepth 1 -type f | sed "s|modules/${module}.mods/||g"))
		echo "#############################################" >> $TARGET.tmp
		echo "#####@AUTOGENERATED '${module}_MODS'" >> $TARGET.tmp
		echo "${module}_MODS=($list)" >> $TARGET.tmp
		for f in $list; do
			echo "#############################################" >> $TARGET.tmp
			echo "#####@ORIGINAL-FILE 'modules/${module}.mods/$f'" >> $TARGET.tmp
			cat modules/${module}.mods/${f} >> $TARGET.tmp
		done
	fi
	echo "#############################################" >> $TARGET.tmp
	echo "#####@ORIGINAL-FILE 'modules/$module'" >> $TARGET.tmp
	cat modules/$module >> $TARGET.tmp
done

# Actual code.
echo "#############################################" >> $TARGET.tmp
echo "#####@ORIGINAL-FILE 'main'" >> $TARGET.tmp
cat main >> $TARGET.tmp

# Remove MERGE_DELs
sed -i '/#####@MERGE_DEL 1/,/#####@MERGE_DEL 0/d' $TARGET.tmp

echo "#############################################" >> $TARGET.tmp

if [ "$BRUTE" = "1" ]; then
	cp $TARGET.tmp $TARGET.raw
fi

if [ "$MINIFY" = "1" ]; then
	# Remove leading and trailing WS.
	sed -i "s/^[[:space:]]*//" $TARGET.tmp
	sed -i "s/[[:space:]]*$//" $TARGET.tmp

	# Remove lines consisting of a comment.
	sed -i "/^[[:space:]]*#.*/d" $TARGET.tmp

	# Remove lines consisting of WS.
	sed -i "/^[[:space:]]*$/d" $TARGET.tmp

	# Replace all instances of "echo" and "echo -e" with 'o'.

	# First define the replacements.
	echo -e "o() {\necho \"\$@\"\n}" >> $TARGET.fun
	echo -e "n() {\necho -ne \"\$@\"\n}" >> $TARGET.fun
	echo -e "e() {\necho -e \"\$@\"\n}" >> $TARGET.fun

	# Now repl.
	sed -i "s/^echo -ne/n/g" $TARGET.tmp
	sed -i "s/^echo -en/n/g" $TARGET.tmp
	sed -i "s/^echo -e/e/g" $TARGET.tmp
	sed -i "s/^echo/o/g" $TARGET.tmp

	# More miscellaneous stripdowns.
	echo 'B="\b\b\b\b\b\b\b\b\b\b"' >> $TARGET.fun
	sed -i 's/\\b\\b\\b\\b\\b\\b\\b\\b\\b\\b/$B/g' $TARGET.tmp

	# We just nuked the shebang, so fix that.
	echo "#!/bin/bash"|cat - $TARGET.fun $TARGET.tmp >> $TARGET.min && mv $TARGET.min $TARGET

	# Some function names and etc can be simplified.
	sed -i "s/auto_/a_/g" $TARGET
	sed -i "s/scrape_/s_/g" $TARGET
	# At this point; this is a micro optimization. It's useless.
	#sed -i "s/dl_/d_/g" $TARGET
	# This rule creates more problems than are needed.
	#sed -i "s/_url/_u/g" $TARGET
	sed -i "s/_longname/_l/g" $TARGET
	sed -i "s/_SPINNER_CHAR/_SC/g" $TARGET
	sed -i "s/spinner/ss/g" $TARGET
	sed -i "s/spinner_done/sd/g" $TARGET

	# Remove tmp.
	rm $TARGET.{fun,tmp}

	if [ "$BRUTE" = "1" ]; then
		cp $TARGET $TARGET.min
	fi
else
	mv $TARGET.tmp $TARGET
fi

if [ "$BRUTE" = "1" ]; then
	xz -9k $TARGET
	bzip2 -9k $TARGET
	gzip -9k $TARGET
	rm $TARGET
	echo "#!/bin/bash" > $TARGET.shbz2
	echo "#!/bin/bash" > $TARGET.shgz
	echo "#!/bin/bash" > $TARGET.shxz
	echo 'eval "$(tail -n+4 "$0" | gzip -d)"' >> $TARGET.shgz
	echo 'eval "$(tail -n+4 "$0" | bzip2 -d)"' >> $TARGET.shbz2
	echo 'eval "$(tail -n+4 "$0" | xz -d)"' >> $TARGET.shxz
	echo 'exit 0' >> $TARGET.shgz
	echo 'exit 0' >> $TARGET.shbz2
	echo 'exit 0' >> $TARGET.shxz
	cat $TARGET.gz >> $TARGET.shgz
	cat $TARGET.bz2 >> $TARGET.shbz2
	cat $TARGET.xz >> $TARGET.shxz
	rm $TARGET.{gz,xz,bz2}
elif [ "$COMPRESS" = "xz" ]; then
	xz -9 $TARGET
	echo "#!/bin/bash" > $TARGET
	echo 'eval "$(tail -n+4 "$0" | xz -d)"' >> $TARGET
	echo 'exit 0' >> $TARGET
	cat $TARGET.xz >> $TARGET
	rm $TARGET.xz
elif [ "$COMPRESS" = "bzip2" ]; then
	bzip2 -9 $TARGET
	echo "#!/bin/bash" > $TARGET
	echo 'eval "$(tail -n+4 "$0" | bzip2 -d)"' >> $TARGET
	echo 'exit 0' >> $TARGET
	cat $TARGET.bz2 >> $TARGET
	rm $TARGET.bz2
elif [ "$COMPRESS" = "gzip" ]; then
	gzip -9 $TARGET
	echo "#!/bin/bash" > $TARGET
	echo 'eval "$(tail -n+4 "$0" | gzip -d)"' >> $TARGET
	echo 'exit 0' >> $TARGET
	cat $TARGET.gz >> $TARGET
	rm $TARGET.gz
fi


# Life needs to be easier.
if [ "$BRUTE" = "1" ]; then
	chmod +x $TARGET.*
else
	chmod +x $TARGET
fi
