#!/bin/bash
# Copyright (C) 2015  Jon Feldman/@chaoskagami
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# These values can be read but should not be written by a module.
COOKIEJAR="$(pwd)/cookiejar"
HAVE_IMAGICK=0
FETCH_RESULT=0

if [ "$VERBOSE" = "" ]; then
	VERBOSE=0
fi

# These values are used by support/core but are controlled by modules.
message=""
use_cookies=0
SAFETY_HACKS=0
CLOBBER=1

# Anything which starts with an underscore is internal and shouldn't be touched.
_COLOR=0
_FETCH_CMD=""
_CHECK_VALID=0
_FETCHTOOL=0
_BUSYBOX=0
_SPINNER_CHAR="|"
_NUM=0

# Tools. Use these variables instead of actual command names.
_tput="$(which tput 2>/dev/null)"
_identify="$(which identify 2>/dev/null)"
_convert="$(which convert 2>/dev/null)"
_wget="$(which wget 2>/dev/null)"
_curl="$(which curl 2>/dev/null)"
_aria="$(which aria2c 2>/dev/null)"

for ((i = 1, n = 2;; n = 1 << ++i)); do
	if [[ ${n:0:1} == '-' ]]; then
		MAX_INT=$(((1 << i) - 1))
		break
	fi
done

#####@INSERT_TYPE
#####@MERGE_DEL 1
type="repo"
#####@MERGE_DEL 0

if [ "$TERM" = "xterm" ] || [ "$TERM" = "linux" ] || [ "$TERM" = "screen" ]; then
	_COLOR=1
	if [ -f $_tput ]; then
		# Better method.
		_COLOR=2
	fi
fi

if [ -f "$_identify" ]; then
	_CHECK_VALID=1
fi

if [ -f "$_identify" ]; then
	HAVE_IMAGICK=1
fi

if [ ! "$_wget" = "" ]; then
	common_opts=" --quiet --no-cache --user-agent=\"Mozilla/5.0\" -t 1 -T 10 --random-wait "

	if [ ! "$($_wget --help 2>&1 | grep busybox)" = "" ]; then
		echo "[Warning] Your system wget is busybox, which can't actually do some things like reject cache and retry."
		common_opts=" -q -U \"Mozilla/5.0\""
		_BUSYBOX=1
	fi

	_FETCH_CMD="$_wget $common_opts"
	_FETCHTOOL=1
else
	if [ ! "$_curl" = "" ]; then
			_FETCH_CMD=$_curl
			_FETCHTOOL=2
	else
		if [ ! "$_aria" = "" ]; then
				_FETCH_CMD=$_aria
				_FETCHTOOL=3
		fi
	fi
fi	

type() {
	if [ $_COLOR = 1 ]; then
		echo -ne "\x1b[$1m"
	elif [ $_COLOR = 2 ]; then
		if [ $1 = 0 ]; then
			tput sgr0
		elif [ $1 = 1 ]; then
			tput bold
		elif [ $1 = 2 ]; then
			tput dim
		fi
	fi
}

color() { 
	if [ $_COLOR = 1 ]; then
		echo -ne "\x1b[3$1m"
	elif [ $_COLOR = 2 ]; then
		tput setaf $1
	fi
}

cbz_make() {
	echo -e "[Post] Making CBZ..."

	# Check and make sure the folder has something, and is actually a folder.
	if [ ! -d "$1" ]; then
		echo -e "\n[Error] Not a folder. Something went wrong."
		exit 1
	fi
	
	if [ "$(ls "$1")" = "" ]; then
		echo "[Error] No files? Download failed."
		exit 1
	fi

	zip -r "$1.zip" "$1" > /dev/null 2>&1
	mv "$1.zip" "$1.cbz" > /dev/null 2>&1
	
	echo -e "[Post] Cleanup..."
	rm -rf "$1"
	echo -e "[Post] Finished!"
}

# Checks if an image is uncorrupted. If you don't have the tools, this never happens.
	# Returns 0 on OK / no tool
	# Returns error code on corrupt
verify() {
	if [ -f $_identify ]; then
		$_identify -verbose -regard-warnings "$1" 2>&1 >/dev/null
		_IDRES=$?
		return $_IDRES
	fi

	return 0
}

spinner() {
	if [ $VERBOSE = 1 ]; then
		echo "Status: $1 - $message"
		return
	fi
	if [ "$_SPINNER_CHAR" = "|" ]; then
		_SPINNER_CHAR="/"
	elif [ "$_SPINNER_CHAR" = "/" ]; then
		_SPINNER_CHAR="-"
	elif [ "$_SPINNER_CHAR" = "-" ]; then
		_SPINNER_CHAR="\\"
	elif [ "$_SPINNER_CHAR" = "\\" ]; then
		_SPINNER_CHAR="|"
	fi

	# Clear previous output
	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne "\b"
	done

	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne " "
	done

	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne "\b"
	done

	STR="[$1 $_SPINNER_CHAR] $message"
	_NUM="${#STR}"

	echo -ne "$STR"
}

spinner_done() {
	if [ $VERBOSE = 1 ]; then
		echo "Status: $1 - $message"
		return
	fi

	# Clear previous output
	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne "\b"
	done

	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne " "
	done

	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne "\b"
	done

	_SPINNER_CHAR="|"
	_NUM=0
	_MESG="OK"
	if [ ! "$1" = "" ]; then
		_MESG="$1"
	fi
	echo -e "[$_MESG]"
}

mimetype() {
	echo "$(file --mime-type "$1" | sed 's/.* //g')"
}


# This creates a cookie jar.
# $1 - Username field
# $2 - Password field
# $3 - Username
# $4 - Password
# $5 - URL
# $6 - extra shit
s_login() {
	if [ $_FETCHTOOL = 1 ]; then
		# WGET
		_CMD="$_FETCH_CMD --post-data='$1=$3&$2=$4&$6' \"$5\"  --load-cookies=$COOKIEJAR --save-cookies=$COOKIEJAR --keep-session-cookies -O/dev/null"

	elif [ $_FETCHTOOL = 2 ]; then
		# CURL
		_CMD="$_FETCH_CMD -d '$1=$3&$2=$4&$6' $5 -b $COOKIEJAR -c $COOKIEJAR >/dev/null"

	elif [ $_FETCHTOOL = 3 ]; then
		#ARIA2C
		# How the fuck do I post? Maybe I can't with araia2c...meh.
		echo "[Warn] aria2c can't post at the moment; this will fail to get required cookies."
		_CMD="$_FETCH_CMD $5 --load-cookies=$COOKIEJAR --save-cookies=$COOKIEJAR -o/dev/null"

	fi
	
	if [ $VERBOSE = 1 ]; then
		echo -e "\n$_CMD"
		return
	fi

	eval " $_CMD" 2>/dev/null
	FETCH_RESULT=$?
}

# AVOID CHANGING THIS FUNCTION IF AT ALL POSSIBLE.
# THINGS WILL BREAK IN EVERYTHING IF THIS ONE BREAKS.
fetch() {
	if [ $_FETCHTOOL = 1 ]; then
		if [ $SAFETY_HACKS = 1 ]; then
			_CMD="$_FETCH_CMD \"$1\""
		else
			_CMD="$_FETCH_CMD --content-disposition \"$1\""
		fi

		if [ ! $CLOBBER = 1 ]; then
			_CMD="$_FETCH_CMD -c \"$1\""
		fi

		if [ $use_cookies = 1 ]; then
			_CMD="$_CMD --load-cookies=$COOKIEJAR --save-cookies=$COOKIEJAR --keep-session-cookies"
		fi

		# Wget uses content-disposition to hopefully get a good name in abscence of one.
		# Of course, that assumes that SAFETY_HACKS is off.

		STDOUT=0
		if [ "$2" = "-" ]; then
			_CMD="$_CMD -O -"
			STDOUT=1
		elif [ ! "$2" = "" ]; then
			_CMD="$_CMD -O \"$2\""
		fi

	elif [ $_FETCHTOOL = 2 ]; then

		_CMD="$_FETCH_CMD $1"
		if [ $use_cookies = 1 ]; then
			_CMD="$_CMD -b $COOKIEJAR -c $COOKIEJAR"
		fi

		if [ "$2" = "" ]; then
			_CMD="$_CMD > $(basename "$1")"
		elif [ "$2" = "-" ]; then
			_CMD="$_CMD"
		else
			_CMD="$_CMD > \"$2\""
		fi

	elif [ $_FETCHTOOL = 3 ]; then

		_CMD="$_FETCH_CMD $1"
		if [ $use_cookies = 1 ]; then
			_CMD="$_CMD --load-cookies=$COOKIEJAR --save-cookies=$COOKIEJAR"
		fi

		if [ "$2" = "" ]; then
			_CMD="$_CMD -o $(basename "$1")"
		elif [ "$2" = "-" ]; then
			_CMD="$_CMD -o -"
		else
			_CMD="$_CMD -o \"$2\""
		fi
	fi
	
	if [ $VERBOSE = 1 ]; then
		echo -e "\n$_CMD"
	fi

	# Wget doesn't have an option to clobber forcibly
	# with content disposition on. I'm so bemused by this
	# that I'm not even sure what to say.
	if [ $CLOBBER = 1 ] && [ $_FETCHTOOL = 1 ] && [ ! $STDOUT = 1 ]; then
		mkdir -p "wget.tmp" 2>/dev/null
		cd wget.tmp
	fi

	eval " $_CMD" 2>/dev/null
	FETCH_RESULT=$?
	
	if [ $CLOBBER = 1 ] && [ $_FETCHTOOL = 1 ] && [ ! $STDOUT = 1 ]; then
		mv ./* ../ 2>/dev/null
		cd ..
		rm -rf wget.tmp
	fi

	# If this is an image, check validity.
	MIME="$(mimetype "$_FILE")"
	if [ "$MIME" = "image/jpeg" ] || [ "$MIME" = "image/png" ] || [ "$MIME" = "image/gif" ] || [ "$MIME" = "image/bmp" ]; then
		verify "$_FILE"
		VALID=$?
		if [ ! $VALID = 0 ]; then
			echo "[WARN] File '$_FILE' is corrupted."
		fi
	fi

	return $FETCH_RESULT
}

entity_to_char() {
	# This probably doesn't handle every case. It should be enough.
	# It also handles the case of illegal characters on windows/FAT/NTFS.
	# And the case of a slash in the name which is the only illegal one on linux.

	sed \
		-e "s/&#32;/ /g" \
		-e "s/&nbsp;/ /g" \
		-e "s/&#33;/\!/g" \
		-e "s/&#34;/\"/g" \
		-e "s/&#35;/\#/g" \
		\
		-e "s/&#36;/\$/g" \
		-e "s/&#37;/\%/g" \
		-e "s/&amp;/\&/g" \
		-e "s/&#38;/\&/g" \
		-e "s/&#39;/'/g" \
		\
		-e "s/&#40;/\(/g" \
		-e "s/&#41;/\)/g" \
		-e "s/&#42;/\*/g" \
		-e "s/&#43;/\+/g" \
		-e "s/&#44;/\,/g" \
		\
		-e "s/&#45;/\-/g" \
		-e "s/&#46;/\./g" \
		-e "s/&#58;/\:/g" \
		-e "s/&#59;/\;/g" \
		-e "s/&lt;/\</g" \
		\
		-e "s/&#60;/\</g" \
		-e "s/&gt/\>/g" \
		-e "s/&#61;/\>/g" \
		-e "s/&#63;/\?/g" \
		-e "s/&#64;/\@/g" \
		\
		-e "s/&#91;/\[/g" \
		-e "s/&#92;/\\\\/g" \
		-e "s/&#93;/\]/g" \
		-e "s/&#94;/\^/g" \
		-e "s/&#95;/\_/g" \
		\
		-e "s/&#123;/\{/g" \
		-e "s/&#124;/\|/g" \
		-e "s/&#125;/\}/g" \
		-e "s/&#126;/\~/g" \
		-e "s/&yen;/¥/g" \
		\
		-e "s/&#165;/¥/g" \
		-e "s/&sup2;/²/g" \
		-e "s/&#178;/²/g" \
		-e "s/&sup3;/³/g" \
		-e "s/&#179;/³/g" \
		\
		-e "s/&frac14;/¼/g" \
		-e "s/&#188;/¼/g" \
		-e "s/&frac12;/½/g" \
		-e "s/&#189;/½/g" \
		-e "s/&frac34;/¾/g" \
		\
		-e "s/&#190;/¾/g" \
		-e "s/&spades;/♠/g" \
		-e "s/&#9824;/♠/g" \
		-e "s/&clubs;/♣/g" \
		-e "s/&#9827;/♣/g" \
		\
		-e "s/&hearts;/♥/g" \
		-e "s/&#9829;/♥/g" \
		-e "s/&diams;/♦/g" \
		-e "s/&#9830;/♦/g"

}

# Known fixed snafus.
# Remove pipe, slash.
# Replace question mark with fullwidth question mark.
remove_illegal() {

	sed \
		-e "s/|/-/g" \
		-e "s|/|-|g" \
		-e "s|?|？|g"

}

reverse_lines() {
    readarray -t LINES
    for (( I = ${#LINES[@]}; I; )); do
        echo "${LINES[--I]}"
    done
}

auto() {
	for module in ${MODS[@]}; do
		auto_${module} "$@"
		RETCHECK=$?
		if [ $RETCHECK = 1 ]; then
			dl_${module} "$@"
		fi
	done
}

batch() {
	# $2 is a file. Read it in line by line as $1 and $2.
	while read chunk; do
		$0 $chunk
	done < $1
}

autobatch() {
	# $2 is a file. Read it in line by line as $1 and $2.
	while read chunk; do
		$0 auto $chunk
	done < $1
}

scrape() {
	for module in ${MODS[@]}; do
		auto_${module} "$@"
		RETCHECK=$?
		if [ $RETCHECK = 1 ]; then
			scrape_${module} "$@"
			exit 0
		fi
	done
}

mod_login() {
	for module in ${MODS[@]}; do
		if [ "$1" = "$module" ]; then
			if [ "$( eval echo \$${module}_uselogin )" = "1" ]; then
				if [ ! "$3" = "" ]; then
					echo "[Warn] Caveat; you probably need to wipe your shell history now. Try not to do it like this."
					username="$2"
					password="$3"
				elif [ ! "$2" = "" ]; then
					username="$2"
					echo -ne "[$module] Password for $username (will not echo): "
					read -s password
				else
					echo -ne "[$module] Username: "
					read username
					echo -ne "[$module] Password for $username (will not echo): "
					read -s password
				fi
				login_${module} "$username" "$password"
				exit 0
			else
				echo "$module does not need login."
				exit 0
			fi
		fi
	done
	echo "No such module."
	exit 1
}

upgrade_self() {
	if [ "$type" = "repo" ]; then
		echo "[Upgrade] You're in a git repo. Use 'git pull' instead."
		exit 0
	fi
	URL="https://raw.githubusercontent.com/chaoskagami/scangrab/$branch/dist/scangrab.$type"
	echo "[Upgrade] Checking this scangrab's sha256sum..."
	this_sha256="$(cat "$0" | sha256sum - | sed "s| .*||g")"
	gith_sha256="$(fetch "$URL.sha256sum" "-" | sed "s| .*||g")"
	if [ "$this_sha256" = "$gith_sha256" ]; then
		echo "[Upgrade] Not required. Same sha256 as upstream."
		exit 0
	else
		echo "[Upgrade] Local:  $this_sha256"
		echo "[Upgrade] Github: $gith_sha256"
		echo "[Upgrade] This doesn't match upstream. Upgrading..."
		fetch "$URL" "$0"
		echo "[Upgrade] We appear to have replaced ourselves. Checking sha256..."
		this_sha256="$(cat "$0" | sha256sum - | sed "s| .*||g")"
		if [ "$this_sha256" = "$gith_sha256" ]; then
			echo "[Upgrade] Succeded."
		else
			echo "[Upgrade] Failed. sha256 does not match github."
			echo "[Upgrade] Make sure you have write permission."
		fi
	fi
}

help() {
	type 1
	echo -e "Usage:"
	type 0
	echo -ne "     $0     "
	color 3
	echo -ne "OPERATION     "
	color 5
	echo -e "[PARAMS]"
	type 0
	type 1
	echo -e "Operations:"
	type 0
	color 3
	echo -e "     auto (a)"
	type 0
	echo -e "          Chooses module based on URL"
	color 3
	echo -e "     batch (l)"
	type 0
	echo -e "          Takes a file with a list of types and URLs"
	color 3
	echo -e "     autobatch (b)"
	type 0
	echo -e "          Takes a file with URLs which will be run with auto."
	color 3
	echo -e "     scrape (s)"
	type 0
	echo -e "          Will take a manga's page and scrape chapters to"
	echo -e "          a file named batch.txt"
	color 3
	echo -e "     login (u)"
	type 0
	echo -e "          Pass the module name, your username and password."
	echo -e "          This will generate a cookie jar as ./cookiejar"
	color 3
	echo -e "     upgrade"
	type 0
	echo -e "          Checks github for a newer copy of scangrab and"
	echo -e "          updates itself. Make sure you have write permission."
	echo -e "          There is no short form of this action."
	echo ""
	echo -e "     You can also specify a module name followed by"
	echo -e "     the URL instead of using the auto-detect."
	echo ""
	echo -e "     If you don't specify an operation and pass only a URL"
	echo -e "     then we assume you want auto (a)."
	type 1
	echo -e "Download Modules:"
	type 0
	for mod in "${MODS[@]}"; do
		longname=$(temp=\$${mod}_longname && eval echo $temp)
		url=$(temp=\$${mod}_url && eval echo $temp)
		broke=$(temp=\$${mod}_state && eval echo $temp)
		filter=$(temp=\$${mod}_filt && eval echo $temp)
		note=$(temp=\$${mod}_note && eval echo $temp)

		echo -ne "     Module Name:                "
		color 3
		echo -e "$mod"

		type 0
		echo -ne "          Long Name:             "
		color 4
		echo -e "$longname"

		type 0
		echo -ne "          Site(s) Used with:     "
		color 5
		echo -e "$url"
		type 0

		type 0
		echo -ne "          Site(s) Current state: "
		if [ "$broke" = "1" ]; then
			color 2
			echo -e "Works"
		elif [ "$broke" = "2" ]; then
			color 3
			echo -e "InDev"
		else
			color 1
			echo -e "Broken"
		fi

		if [ ! "$note" = "" ]; then
			type 0
			echo -e "          Site Note:             $note"
		fi

		type 0
		if [ "$filter" = "1" ]; then
			echo -e "          Supports filters for scrape"
		fi

		echo ""
	done
	type 1
	echo -e "Misc Info"
	type 0
	echo -e "     If you see an emote in the output, it means we had to deal"
	echo -e "     with a retrieval quirk."
	echo -e "\n     [ :/ ]       Given GZip'd data even though we said it wasn't"
	echo -e "                  supported in the GET."
	type 2
	echo -e "                  This happens frequently with batoto when doing"
	echo -e "                  multiple fetches. :/"
	type 0
	echo -e "\n     [ :( ]       Site didn't respond and so the DL failed"
	echo -e "                  We had to revert to a fallback method."

	echo -e "\n     [ >:( ]      Too many normal requests failed; we reverted"
	echo -e "                  to using entirely the fallback method."
	echo ""
	echo -e "     Some modules accept an extra parameter. Usually, this"
	echo -e "     is a filter. Try values like 'English' or 'French'."
	type 1
	echo -e "System Tools"
	type 0
	if [ ! "$_wget" = "" ]; then
		echo -e "     wget:                $_wget"
	fi
	if [ ! "$_curl" = "" ]; then
		echo -e "     curl:                $_curl"
	fi
	if [ ! "$_aria" = "" ]; then
		echo -e "     aria2c:              $_aria"
	fi
	echo -ne "     Will use:            "
	if [ $_FETCHTOOL = 1 ]; then
		echo -ne "wget"
		if [ $_BUSYBOX = 1 ]; then
			echo -ne ", busybox"
		else
			echo -ne ""
		fi
	elif [ $_FETCHTOOL = 2 ]; then
		echo -ne "curl"
	elif [ $_FETCHTOOL = 3 ]; then
		echo -ne "aria2c"
	else
		echo -ne "no tool. Install one of: "
	fi
	echo " (wget, curl, aria2c)"
	echo -ne "     Check broken images: "
	if [ $_CHECK_VALID = 1 ]; then
		if [ -f $_identify ]; then
			echo -ne "imagemagick ($_identify)"
		fi
		echo ""
	else
		echo "no"
	fi
	echo -ne "     Color:               "
	if [ $_COLOR = 1 ]; then
		color 1
		echo -ne "y"
		color 2
		echo -ne "e"
		color 3
		echo -ne "s"
		color 4
		echo -ne " "
		echo -ne "("
		color 5
		echo -ne "d"
		color 6
		echo -ne "u"
		color 1
		echo -ne "m"
		color 2
		echo -ne "b"
		color 3
		echo ")"
		type 0
	elif [ $_COLOR = 2 ]; then
		color 1
		echo -ne "y"
		color 2
		echo -ne "e"
		color 3
		echo -ne "s"
		color 4
		echo -ne " "
		echo -ne "("
		color 5
		echo -ne "t"
		color 6
		echo -ne "p"
		color 1
		echo -ne "u"
		color 2
		echo -ne "t"
		color 3
		echo ")"
		type 0
	else
		echo "no (TERM='$TERM')"
	fi
	type 1
	echo -ne "License / Info"
	type 0
	echo ""
	echo -e "     Copyright (C) 2015     Jon Feldman/@chaoskagami"
	echo ""
	echo -e "     This program is free software: you can redistribute it and/or modify"
	echo -e "     it under the terms of the GNU General Public License as published by"
	echo -e "     the Free Software Foundation, either version 3 of the License, or"
	echo -e "     (at your option) any later version."
	echo ""
	echo -e "     This program is distributed in the hope that it will be useful,"
	echo -e "     but WITHOUT ANY WARRANTY; without even the implied warranty of"
	echo -e "     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
	echo -e "     GNU General Public License for more details."
	echo ""
	echo -e "     You should have received a copy of the GNU General Public License"
	echo -e "     along with this program.  If not, see <http://www.gnu.org/licenses/>"
	echo ""
	echo -e "     The latest version of scangrab can always be found at the github"
	echo -e "     page here: https://github.com/chaoskagami/scangrab"
	echo ""
	echo -e "     Build: $type, $branch, $rev"
}
