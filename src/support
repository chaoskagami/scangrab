#!/bin/bash
# Copyright (C) 2015  Jon Feldman/@chaoskagami
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

type() {
	echo -ne "\x1b[$1m"
}

color() {
	echo -ne "\x1b[3$1m"
}

cbz_make() {
	echo -ne "[Post] Making CBZ..."

	# Check and make sure the folder has something, and is actually a folder.
	if [ ! -d "$1" ]; then
		echo -e "\n[Error] Not a folder. Something went wrong."
		exit 1
	fi
	
	if [ "$(ls "$1")" = "" ]; then
		echo "[Error] No files? Download failed."
		exit 1
	fi

	zip -r "$1.zip" "$1" > /dev/null 2>&1
	mv "$1.zip" "$1.cbz" > /dev/null 2>&1
	
	echo -ne "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b[Post] Cleanup..."
	rm -rf "$1"
	echo -e "\b\b\b\b\b\b\b\b\b\bFinished.    "
}

# Checks if an image is uncorrupted. If you don't have the tools, this never happens.
	# Returns 0 on OK / no tool
	# Returns code on corrupt

verify() {
	_identify=$(which identify 2>/dev/null)

	if [ -f $_identify ]; then
		$_identify -verbose -regard-warnings "$1" 2>&1 >/dev/null
		_IDRES=$?
		return $_IDRES
	fi

	return 0
}

_SPINNER_CHAR="|"
_NUM=0
_FIRST=1
message=""
spinner() {
	if [ $_FIRST = 1 ]; then
		_FIRST=0
	else
		echo -ne "\b\b\b\b"
	fi

	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne "\b"
	done

	if [ "$_SPINNER_CHAR" = "|" ]; then
		_SPINNER_CHAR="/"
	elif [ "$_SPINNER_CHAR" = "/" ]; then
		_SPINNER_CHAR="-"
	elif [ "$_SPINNER_CHAR" = "-" ]; then
		_SPINNER_CHAR="\\"
	elif [ "$_SPINNER_CHAR" = "\\" ]; then
		_SPINNER_CHAR="|"
	fi

	_NUM=${#1}
	echo -ne "[$1 $_SPINNER_CHAR]"

	_STS=${#message}
	echo -ne "$message"
	for (( i=0 ; i < _STS ; i++ )); do
		echo -ne "\b"
	done
}

done_spin() {
	for (( i=0 ; i < _NUM ; i++ )); do
		echo -ne "\b"
	done
	echo -e "\b\b\b[OK]"
}

mimetype() {
	echo "$(file --mime-type "$1" | sed 's/.* //g')"
}

FETCH_RESULT="0"
FETCH_CMD=""
_FETCHTOOL=0
_BUSYBOX=0
fetch_detect() {
	_wget="$(which wget 2>/dev/null)"
	_curl="$(which curl 2>/dev/null)"
	_aria="$(which aria2c 2>/dev/null)"

	if [ ! "$_wget" = "" ]; then
		common_opts=" --quiet --no-cache --user-agent=\"Mozilla/4.0\" -c -t 1 -T 10 --random-wait "

		if [ ! "$($_wget --help 2>&1 | grep busybox)" = "" ]; then
			echo "[Warning] Your system wget is busybox, which can't actually do some things like reject cache and retry."
			common_opts=" -q -c -U \"Mozilla/4.0\""
			_BUSYBOX=1
		fi

		FETCH_CMD="$_wget $common_opts"
		_FETCHTOOL=1
	else
		if [ ! "$_curl" = "" ]; then
				FETCH_CMD=$_curl
				_FETCHTOOL=2
		else
			if [ ! "$_aria" = "" ]; then
					FETCH_CMD=$_aria
					_FETCHTOOL=3
			fi
		fi
	fi

	return $FETCH_RESULT	
}

# AVOID CHANGING THIS FUNCTION IF AT ALL POSSIBLE.
# THINGS WILL BREAK IN EVERYTHING IF THIS ONE BREAKS.

fetch() {
	if [ $_FETCHTOOL = 1 ]; then

		_CMD="$FETCH_CMD \"$1\""
		if [ "$2" = "" ]; then
			_CMD="$_CMD -O $(basename "$1")"
		elif [ "$2" = "-" ]; then
			_CMD="$_CMD -O -"
		else
			_CMD="$_CMD -O \"$2\""
		fi

	elif [ $_FETCHTOOL = 2 ]; then

		_CMD="$FETCH_CMD $1"
		if [ "$2" = "" ]; then
			_CMD="$_CMD > $(basename "$1")"
		elif [ "$2" = "-" ]; then
			_CMD="$_CMD"
		else
			_CMD="$_CMD > \"$2\""
		fi

	elif [ $_FETCHTOOL = 3 ]; then

		_CMD="$FETCH_CMD $1"
		if [ "$2" = "" ]; then
			_CMD="$_CMD -o $(basename "$1")"
		elif [ "$2" = "-" ]; then
			_CMD="$_CMD -o -"
		else
			_CMD="$_CMD -o \"$2\""
		fi
	fi
	
	# echo -e "\n$_CMD"
	eval " $_CMD" 2>/dev/null
	FETCH_RESULT=$?

	#if [ ! $FETCH_RESULT = 0 ]; then
		#if [ ! "$3" = "nowarn" ]; then # Suppress warnings.
			#echo -e "[WARN] Failed to fetch. Command was:\n$_CMD"
		#fi
	#elif [ $_BUSYBOX = 1 ] && [ ! $FETCH_RESULT = 0 ]; then
		#echo "[WARN] Image failed on busybox. Cannot retry."
	#fi
	
	# If this is an image, check validity.
	MIME="$(mimetype "$_FILE")"
	if [ "$MIME" = "image/jpeg" ] || [ "$MIME" = "image/png" ] || [ "$MIME" = "image/gif" ] || [ "$MIME" = "image/bmp" ]; then
		verify "$_FILE"
		VALID=$?
		if [ ! $VALID = 0 ]; then
			echo "[WARN] File '$_FILE' is corrupted."
		fi
	fi

	return $FETCH_RESULT
}

entity_to_char() {
	# This probably doesn't handle every case. It should be enough.
	# It also handles the case of illegal characters on windows/FAT/NTFS

	sed \
		-e "s/&#32;/ /g" \
		-e "s/&nbsp;/ /g" \
		-e "s/&#33;/\!/g" \
		-e "s/&#34;/\"/g" \
		-e "s/&#35;/\#/g" \
		\
		-e "s/&#36;/\$/g" \
		-e "s/&#37;/\%/g" \
		-e "s/&amp;/\&/g" \
		-e "s/&#38;/\&/g" \
		-e "s/&#39;/'/g" \
		\
		-e "s/&#40;/\(/g" \
		-e "s/&#41;/\)/g" \
		-e "s/&#42;/\*/g" \
		-e "s/&#43;/\+/g" \
		-e "s/&#44;/\,/g" \
		\
		-e "s/&#45;/\-/g" \
		-e "s/&#46;/\./g" \
		-e "s/&#58;/\:/g" \
		-e "s/&#59;/\;/g" \
		-e "s/&lt;/\</g" \
		\
		-e "s/&#60;/\</g" \
		-e "s/&gt/\>/g" \
		-e "s/&#61;/\>/g" \
		-e "s/&#63;/\?/g" \
		-e "s/&#64;/\@/g" \
		\
		-e "s/&#91;/\[/g" \
		-e "s/&#92;/\\\\/g" \
		-e "s/&#93;/\]/g" \
		-e "s/&#94;/\^/g" \
		-e "s/&#95;/\_/g" \
		\
		-e "s/&#123;/\{/g" \
		-e "s/&#124;/\|/g" \
		-e "s/&#125;/\}/g" \
		-e "s/&#126;/\~/g" \
		-e "s/&yen;/¥/g" \
		\
		-e "s/&#165;/¥/g" \
		-e "s/&sup2;/²/g" \
		-e "s/&#178;/²/g" \
		-e "s/&sup3;/³/g" \
		-e "s/&#179;/³/g" \
		\
		-e "s/&frac14;/¼/g" \
		-e "s/&#188;/¼/g" \
		-e "s/&frac12;/½/g" \
		-e "s/&#189;/½/g" \
		-e "s/&frac34;/¾/g" \
		\
		-e "s/&#190;/¾/g" \
		-e "s/&spades;/♠/g" \
		-e "s/&#9824;/♠/g" \
		-e "s/&clubs;/♣/g" \
		-e "s/&#9827;/♣/g" \
		\
		-e "s/&hearts;/♥/g" \
		-e "s/&#9829;/♥/g" \
		-e "s/&diams;/♦/g" \
		-e "s/&#9830;/♦/g" \
		\
		-e "s/|/-/g"
}

reverse_lines() {
    readarray -t LINES
    for (( I = ${#LINES[@]}; I; )); do
        echo "${LINES[--I]}"
    done
}
